# vue3_teach_youself
a rookie travel

## Suspense 
在react里文档的用途是让组件“等待”某个异步操作，直到该异步操作结束即可渲染。
- 它能让数据获取库与 React 紧密整合。如果一个数据请求库实现了对 Suspense 的支持，那么，在 React 中使用 Suspense 将会是自然不过的事。
- 它能让你有针对性地安排加载状态的展示。虽然它不干涉数据怎样获取，但它可以让你对应用的视图加载顺序有更大的控制权。
- 它能够消除 race conditions（Race Conditions 是由于对代码运行顺序的错误假设而导致的 bug）。即便是用上 await，异步代码还是很容易出错。相比之下，Suspense 更给人同步读取数据的感觉 —— 假定数据已经加载完毕。

基本上是用来梳理获取数据与渲染的时序关系，这个又有三种方式
- Fetch-on-render（渲染之后获取数据，如：在 useEffect 中 fetch）：先开始渲染组件，每个完成渲染的组件都可能在它们的 effects 或者生命周期函数中获取数据。这种方式经常导致“瀑布”问题。
- Fetch-then-render（接收到全部数据之后渲染，如：不使用 Suspense 的 Relay）：先尽早获取下一屏需要的所有数据，数据准备好后，渲染新的屏幕。但在数据拿到之前，我们什么事也做不了。
- Render-as-you-fetch（获取数据之后渲染，如：使用了 Suspense 的 Relay）：先尽早获取下一屏需要的所有数据，然后立刻渲染新的屏幕——在网络响应可用之前就开始。在接收到数据的过程中，React迭代地渲染需要数据的组件，直到渲染完所有内容为止。

又想起一句话，所有异步操作都是为了实现一个完美的同步。即数据的请求获得与渲染的完成，能尽可能的同时完成，故采用了Suspense。让获取数据与渲染更自然，获取数据便会挂起组件渲染过程，去渲染别的组件，数据获得到了就回来渲染。这一切都通过suspense 自动完成了。非常的amazing。

()=>import()是异步组件。能略微的提速页面的加载速度，如果你使用v-if去包裹这个组件的话，即只有在渲染的时候才会通过webpack 2 和 ES2015的语法，返回个promise，来加载这个组件并渲染。和suspense处理数据与渲染的逻辑存在区别。基本使用上类似于Fetch-then-render。

## 为什么是hook，不是class
hook作为react 16引入的新特性，自然vue也是从友商那学到了这一招，代替了之前的class写法，有以下几点原因
- 复杂组件难以维护，特别是组件耦合了许多不相关功能，需要将其解耦，**Hook 将组件中相互关联的部分拆分成更小的函数**，可以更好的做代码复用和管理。
- 难以理解的 class，class作为一个编程学概念，一直是学习如何使用react框架的前置知识，使用class必须去理解 JavaScript 中 this 的工作方式，但是在框架的使用中却显得有些多余复杂了，一般更希望去理解 props，state 和自顶向下的数据流，但对class有些困难。所以将其替代为函数组件，更清晰的去展现数据与渲染逻辑。**Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。**


  

## 3.0的vdom
vdom概念
vdom 数据驱动ui，将Dom用js对象去描述。，开发者只需考虑数据变化，便能自动变化UI。
2.0
传统的vdom，在数据变更后会将新的vdom与老的vdom进行patch函数处理比较，将差异作为补丁打在现有的vdom上。进行算法比对的颗粒度是组件。以组件作为颗粒进行比较，vue2在单个组件内部仍需使用patch遍历整个组件的vdom树，再计算出patch。传统方案计算量和动态数据的节点数量无关而与模板的大小正相关，要是模板越大，进行更新时的性能损耗也越大。
3.0
极致的性能则是利用模板进行数据监听，数据变化直接更新对应的dom元素，例如svelte框架无vdom。这种对模板的确定性要求很高，模板一旦确定，进行预编译即可。

但无法利用js的灵活性。无法使用render function/JSX这种需要vdom进行中介的写法。vue3 为了兼容template和render function，采用了集中方式来优化vdom。
就是在模板编译时，打上不同的type，来根据不同的type来进行不同的vdom处理。

**动静有别** 通过模板编译时打上patchFlag，区分动态静态节点
  
patchFlag 的存在意味着此元素的呈现代码是由编译器生成，并可以采取快速路径。
在此路径中，旧节点和新节点保证具有相同的形状（即在源模板中的完全相同的位置）

> 注意： 若是采用jsx来写vue3，也就不通过模板编译，也就无法预先优化vdom了

## 3.0的reactive
2.0的响应式是基于 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新。
- 然而Object.defineProperty只能监听对象的属性，即对象在其他地方新增删除属性，不会被监听到
- 在初始化data的时候需要遍历一个对象的深层结构，将其都挂在在监听函数下，效率低
- 对于Array的支持较差，还记得修改数组必须用数组的变异方法才能响应式的修改数组内容吗？，或者调用vue.$set去重新挂载上响应式吗？

3.0基于 ES6的proxy，可以直接对对象进行监听。初始化也无需深度遍历对象。对Array完全支持。


## Portals VS  teleport 
portal即传送门，将一个子节点渲染至某一特定dom节点上，一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框。源自react文档，vue3没有见过用例。
