# vue3_teach_youself
a rookie travel

## Suspense 
在react里文档的用途是让组件“等待”某个异步操作，直到该异步操作结束即可渲染。
- 它能让数据获取库与 React 紧密整合。如果一个数据请求库实现了对 Suspense 的支持，那么，在 React 中使用 Suspense 将会是自然不过的事。
- 它能让你有针对性地安排加载状态的展示。虽然它不干涉数据怎样获取，但它可以让你对应用的视图加载顺序有更大的控制权。
- 它能够消除 race conditions（Race Conditions 是由于对代码运行顺序的错误假设而导致的 bug）。即便是用上 await，异步代码还是很容易出错。相比之下，Suspense 更给人同步读取数据的感觉 —— 假定数据已经加载完毕。

基本上是用来梳理获取数据与渲染的时序关系，这个又有三种方式
- Fetch-on-render（渲染之后获取数据，如：在 useEffect 中 fetch）：先开始渲染组件，每个完成渲染的组件都可能在它们的 effects 或者生命周期函数中获取数据。这种方式经常导致“瀑布”问题。
- Fetch-then-render（接收到全部数据之后渲染，如：不使用 Suspense 的 Relay）：先尽早获取下一屏需要的所有数据，数据准备好后，渲染新的屏幕。但在数据拿到之前，我们什么事也做不了。
- Render-as-you-fetch（获取数据之后渲染，如：使用了 Suspense 的 Relay）：先尽早获取下一屏需要的所有数据，然后立刻渲染新的屏幕——在网络响应可用之前就开始。在接收到数据的过程中，React迭代地渲染需要数据的组件，直到渲染完所有内容为止。

又想起一句话，所有异步操作都是为了实现一个完美的同步。即数据的请求获得与渲染的完成，能尽可能的同时完成，故采用了Suspense。让获取数据与渲染更自然，获取数据便会挂起组件渲染过程，去渲染别的组件，数据获得到了就回来渲染。这一切都通过suspense 自动完成了。非常的amazing。

()=>import()是异步组件。能略微的提速页面的加载速度，如果你使用v-if去包裹这个组件的话，即只有在渲染的时候才会通过webpack 2 和 ES2015的语法，返回个promise，来加载这个组件并渲染。和suspense处理数据与渲染的逻辑存在区别。基本使用上类似于Fetch-then-render。

## 3.0的dom更新的算法

## 3.0的vdom

## Portals VS  teleport 
portal即传送门，将一个子节点渲染至某一特定dom节点上，一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：
